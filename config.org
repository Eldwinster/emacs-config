#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+embed: LICENCE :description MIT licence file
#+options: coverpage:yes
#+startup: fold

* Rudimentary configuration

Make this file run (slightly) faster with lexical binding (see [[https://nullprogram.com/blog/2016/12/22/][this blog post]]
for more info).
#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/usr/bin/env bash
#+end_src
** Better defaults
*** Simple settings

Browsing the web and seeing [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]] and comparing with the values
shown by =SPC h v= and selecting what I thought looks good, I've ended up adding
the following:

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "â€¦"                ; Unicode ellispis are nicer than "...", and also save /precious/ space
      password-cache-expiry nil                   ; I can trust my computers ... can't I?
      ;; scroll-preserve-screen-position 'always     ; Don't have `point' jump around
      scroll-margin 2)                            ; It's nice to maintain a little margin

(display-time-mode 1)                             ; Enable time in the mode-line

(unless (string-match-p "^Power N/A" (battery))   ; On laptops...
  (display-battery-mode 1))                       ; it's nice to know how much power you have

(global-subword-mode 1)                           ; Iterate through CamelCase words
#+end_src

*** Auto-customisations

By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

*** Windows

I find it rather handy to be asked which buffer I want to see after splitting
the window. Let's make that happen.

First, we'll enter the new window
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Then, we'll pull up a buffer prompt.
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src
** Doom configuration
*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Doom has this lovely /modular configuration base/ that takes a lot of work out of
configuring Emacs. Each module (when enabled) can provide a list of packages to
install (on ~doom sync~) and configuration to be applied. The modules can also
have flags applied to tweak their behaviour.
#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :noweb-prefix no :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>)
#+end_src
**** Structure
As you may have noticed by this point, this is a [[https://en.wikipedia.org/wiki/Literate_programming][literate]] configuration. Doom
has good support for this which we access though the ~literate~ module.

While we're in the src_elisp{:config} section, we'll use Dooms nicer defaults,
along with the bindings and smartparens behaviour (the flags aren't documented,
but they exist).
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src
**** Interface
There's a lot that can be done to enhance Emacs' capabilities.
I reckon enabling half the modules Doom provides should do it.
#+name: doom-completion
#+begin_src emacs-lisp
(company                     ; the ultimate code completion backend
 +childframe)                ; ... when your children are better than you
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
;; (ivy                      ; a search engine for love and life
;;  +icons                   ; ... icons are nice
;;  +prescient)              ; ... I know what I want(ed)
(vertico +icons)             ; the search engine of the future
#+end_src
#+name: doom-ui
#+begin_src emacs-lisp
;;deft                       ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
doom-quit                    ; DOOM quit-message prompts when you quit Emacs
;; (emoji +unicode)             ; ðŸ™‚
;;fill-column                ; a `fill-column' indicator
;; hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra                      ; quick documentation for related commands
;;indent-guides              ; highlighted indent columns, notoriously slow
;; (ligatures +extra)           ; ligatures and symbols to make your code pretty again
;;minimap                    ; show a map of the code on the side
;; modeline                     ; snazzy, Atom-inspired modeline, plus API
(modeline +light)                     ; snazzy, Atom-inspired modeline, plus API
;; nav-flash                    ; blink the current line after jumping
;;neotree                    ; a project drawer, like NERDTree for vim
;; ophints                      ; highlight the region an operation acts on
;; popup                       ; tame sudden yet inevitable temporary windows
(popup                       ; tame sudden yet inevitable temporary windows
 ;; +all                        ; catch all popups that start with an asterix
 +defaults)                  ; default popup rules
;;(tabs                      ; an tab bar for Emacs
;;  +centaur-tabs)           ; ... with prettier tabs
;; treemacs                     ; a project drawer, like neotree but cooler
(treemacs +lsp)                     ; a project drawer, like neotree but cooler
;; unicode                    ; extended unicode support for various languages
;; (vc-gutter +pretty)          ; vcs diff in the fringe
;; vi-tilde-fringe              ; fringe tildes to mark beyond EOB
;; (window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
;; zen                          ; distraction-free coding or writing
#+end_src
#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
;; (format)                     ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
;;lispy                      ; vim for lisp, for people who don't like vim
;; multiple-cursors             ; editing in many places at once
;;objed                      ; text object editing for the innocent
;;parinfer                   ; turn lisp into python, sort of
;; rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
;;word-wrap                  ; soft wrapping with language-aware indent
#+end_src
#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)               ; making dired pretty [functional]
;; electric                     ; smarter, keyword-based electric-indent
;; (ibuffer +icons)             ; interactive buffer management
undo                         ; persistent, smarter undo for your inevitable mistakes
;; vc                           ; version-control and Emacs, sitting in a tree
#+end_src
#+name: doom-term
#+begin_src emacs-lisp
eshell                     ; the elisp shell that works everywhere
;;shell                      ; simple shell REPL for Emacs
;;term                       ; basic terminal emulator for Emacs
vterm                        ; the best terminal emulation in Emacs
#+end_src
#+name: doom-checkers
#+begin_src emacs-lisp
syntax                       ; tasing you for every semicolon you forget
(:if (executable-find "aspell") spell) ; tasing you for misspelling mispelling
grammar                      ; tasing grammar mistake every you make
#+end_src
#+name: doom-tools
#+begin_src emacs-lisp
;; ansible                      ; a crucible for infrastructure as code
;; biblio                       ; for Phd
;;debugger                   ; FIXME stepping through code, to help you add bugs
;; (debugger +lsp)                   ; FIXME stepping through code, to help you add bugs
;;direnv                     ; be direct about your environment
;; docker                       ; port everything to containers
;;editorconfig               ; let someone else argue about tabs vs spaces
;;ein                        ; tame Jupyter notebooks with emacs
;; (eval +overlay)              ; run code, run (also, repls)
;;gist                       ; interacting with github gists
;; lookup                      ; helps you navigate your code and documentation
(lookup                      ; helps you navigate your code and documentation
 +dictionary                 ; dictionary/thesaurus is nice
 +docsets)                   ; ...or in Dash docsets locally
;; lsp                          ; Language Server Protocol
(lsp                          ; Language Server Protocol
 +peek)                         ; when looking up definitions and references, use lookup
;;macos                      ; MacOS-specific commands
magit                       ; a git porcelain for Emacs
;; (magit                       ; a git porcelain for Emacs
;;  +forge)                     ; interface with git forges
;; make                         ; run make tasks from Emacs
;;pass                       ; password manager for nerds
pdf                          ; pdf enhancements
;;prodigy                    ; FIXME managing external services & code builders
;; rgb                          ; creating color strings
;;taskrunner                 ; taskrunner for all your projects
;;terraform                  ; infrastructure as code
;;tmux                       ; an API for interacting with tmux
;;tree-sitter                ; syntax and parsing, sitting in a tree...
;; upload                       ; map local to remote projects via ssh/ftp
#+end_src
#+name: doom-os
#+begin_src emacs-lisp
;; (:if IS-MAC macos)  ; improve compatibility with macOS
tty               ; improve the terminal Emacs experience
#+end_src
**** Language support
We can be rather liberal with enabling support for languages as the associated
packages/configuration are (usually) only loaded when first opening an
associated file.
#+name: doom-lang
#+begin_src emacs-lisp
;;agda                       ; types of types of types of types...
;;beancount                  ; mind the GAAP
;;(cc +lsp)                  ; C > C++ == 1
;;clojure                    ; java with a lisp
;;common-lisp                ; if you've seen one lisp, you've seen them all
;;coq                        ; proofs-as-programs
;;crystal                    ; ruby at the speed of c
;;csharp                     ; unity, .NET, and mono shenanigans
;; data                         ; config/data formats
;;(dart +flutter)            ; paint ui and not much else
;;dhall                      ; JSON with FP sprinkles
;;elixir                     ; erlang done right
;;elm                        ; care for a cup of TEA?
emacs-lisp                   ; drown in parentheses
;;erlang                     ; an elegant language for a more civilized age
;; ess                          ; emacs speaks statistics
;;faust                      ; dsp, but you get to keep your soul
;;fsharp                     ; ML stands for Microsoft's Language
;;fstar                      ; (dependent) types and (monadic) effects and Z3
;;gdscript                   ; the language you waited for
;;(graphql +lsp)             ; Give queries a REST
(go +lsp)                  ; the hipster dialect
;; (haskell +lsp)             ; a language that's lazier than I am
;;hy                         ; readability of scheme w/ speed of python
;;idris                      ;
;; json                         ; At least it ain't XML
;;(java +lsp)                ; the poster child for carpal tunnel syndrome
;; (javascript +lsp)            ; all(hope(abandon(ye(who(enter(here))))))
;; (julia +lsp)                 ; Python, R, and MATLAB in a blender
;;kotlin                     ; a better, slicker Java(Script)
(latex                       ; writing papers in Emacs has never been so fun
 +latexmk                    ; what else would you use?
 +cdlatex                    ; quick maths symbols
 +fold)                      ; fold the clutter away nicities
;;lean                       ; proof that mathematicians need help
;;factor                     ; for when scripts are stacked against you
;;ledger                     ; an accounting system in Emacs
;; lua                          ; one-based indices? one-based indices
;; markdown                     ; writing docs for people to ignore
;;nim                        ; python + lisp at the speed of c
;;nix                        ; I hereby declare "nix geht mehr!"
;;ocaml                      ; an objective camel
;; org                         ; organize your plain life in plain text
(org                         ; organize your plain life in plain text
 ;; +brain                         ; main map like brain
 ;; +dragndrop                  ; drag & drop files/images into org buffers
 +gnuplot                    ; who doesn't like pretty pictures
 ;;+hugo                     ; use Emacs for hugo blogging
 +journal                       ; Personal diary
 ;; +jupyter                    ; ipython/jupyter support for babel
 +noter                      ; enhanced PDF notetaking
 +pandoc                     ; export-with-pandoc support
 ;;+pomodoro                 ; be fruitful with the tomato technique
 +present                    ; using org-mode for presentations
 +roam2)                     ; wander around notes
;; php                        ; perl's insecure younger brother
(php +lsp)                        ; perl's insecure younger brother
plantuml                   ; diagrams for confusing people more
;;purescript                 ; javascript, but functional
(python +lsp +pyright)       ; beautiful is better than ugly
;;qt                         ; the 'cutest' gui framework ever
;;racket                     ; a DSL for DSLs
;;raku                       ; the artist formerly known as perl6
;;rest                       ; Emacs as a REST client
;;rst                        ; ReST in peace
;;(ruby +rails)              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
;; (rust +lsp)                  ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala                      ; java, but good
;; scheme                       ; a fully conniving family of lisps
;; sh                           ; she sells {ba,z,fi}sh shells on the C xor
(sh                           ; she sells {ba,z,fi}sh shells on the C xor
 +lsp                           ; Enable LSP support for sh-mode
 +powershell)                   ; Add syntax highlighting for Powershell script
;;sml                        ; no, the /other/ ML
;;solidity                   ; do you need a blockchain? No.
;;swift                      ; who asked for emoji variables?
;;terra                      ; Earth and Moon in alignment for performance.
;; web                          ; the tubes
(web +lsp)                          ; the tubes
(yaml +lsp)                         ; JSON, but readable
;;zig                        ; C, but simpler
#+end_src
**** Input
#+name: doom-input
#+begin_src emacs-lisp
;;bidi                       ; (tfel ot) thgir etirw uoy gnipleh
;;chinese
;;japanese
;;layout                     ; auie,ctsrnm is the superior home row
#+end_src
**** Everything in Emacs
It's just too convenient being able to have everything in Emacs.
I couldn't resist the Email and Feed modules.
#+name: doom-email
#+begin_src emacs-lisp
;; (:if (executable-find "mu") (mu4e +org +gmail))
;;notmuch
;;(wanderlust +gmail)
#+end_src
#+name: doom-app
#+begin_src emacs-lisp
;;calendar                   ; A dated approach to timetabling
;;emms                       ; Multimedia in Emacs is music to my ears
everywhere                   ; *leave* Emacs!? You must be joking.
;; irc                          ; how neckbeards socialize
;; (rss +org)                   ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src
*** Visual Settings
**** Font Face
'Fira Code' is nice, and 'Overpass' makes for a nice sans companion. We just need to
fiddle with the font sizes a tad so that they visually match. Just for fun I'm
trying out JetBrains Mono though. So far I have mixed feelings on it, some
aspects are nice, but on others I prefer Fira.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "FiraCode Nerd Font" :size 15)
      doom-big-font (font-spec :family "FiraCode Nerd Font" :size 24)
      doom-variable-pitch-font (font-spec :family "Overpass Nerd Font" :size 15)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :size 22 :weight 'light))
#+end_src

#+attr_html: :class invertible :alt Screenshot of the fonts within Emacs.
[[https://tecosaur.com/lfs/emacs-config/screenshots/font-face.png]]

In addition to these fonts, Merriweather is used with =nov.el=, and Alegreya as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

Because we care about how things look let's add a check to make sure we're told
if the system doesn't have any of those fonts.
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("FiraCode Nerd Font" "Overpass Nerd Font" "IBM Plex Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts()>>
#+end_src
This way whenever fonts are missing, after Doom's UI has initialised, a warning
listing the missing fonts should appear for at least half a second.
**** Theme, transparency and modeline
As I like pywal, I tried to find a way to use it within emacs. However, this doesn't look that good most of the time. By that I mean that I lose in lisibility so that quite inefficient way to use a theme.
That why I set a fixed theme within emacs, pywal be damned I prefer to see what I'm doing than using a shiny useless tool. I still keep the code maybe be there is a way to fix some color and while keeping the feature of wal in some aspects.
#+begin_src emacs-lisp :tangle no
(defvar my-wal-colors nil)

(defun my-refresh-wal-colors ()
  (setq my-wal-colors
        (with-temp-buffer
          (insert-file-contents "~/.cache/wal/colors.json")
          (goto-char (point-min))
          (json-read))))

(defun my-xresources-theme-color (name)
  (let ((category
         (if (or (string= name "background")
                 (string= name "foreground"))
             'special
           'colors)))
    (cdr
     (assoc (intern name)
            (assoc category my-wal-colors)))))

(advice-add 'xresources-theme-color :override 'my-xresources-theme-color)

(defun my-load-xresources ()
  (my-refresh-wal-colors)
  (load-theme 'xresources t))
#+end_src

~doom-one~ is nice and all, but I find the ~vibrant~ variant nicer. Oh, and with the
nice selection doom provides there's no reason for me to want the defaults.
#+begin_src emacs-lisp
(setq doom-theme 'doom-acario-dark)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)
#+end_src

Why would you use all those beautiful wallpaper, while most of the time you won't see them.
As I like my wallpaper, I quite like transparency, so here it is.
#+begin_src emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(85 . 80))
(add-to-list 'default-frame-alist '(alpha . (85 . 80)))
;; Set transparency of emacs
(defun transparency (value)
  "Sets the transparency of the frame window. 0=transparent/100=opaque"
  (interactive "nTransparency Value 0 - 100 opaque:")
  (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

However, by default ~red~ text is used in the ~modeline~, so let's make that orange
so I don't feel like something's gone /wrong/ when editing files.
#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src

While we're modifying the modeline, =LF UTF-8= is the default file encoding, and
thus not worth noting in the modeline. So, let's conditionally hide it.
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src
**** Miscellaneous
Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

I'd like some slightly nicer default buffer names
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "â–º Doom"
      +doom-dashboard-name "â–º Doom")
#+end_src
*** Some helper macros
There are a few handy macros added by doom, namely
- ~load!~ for loading external ~.el~ files relative to this one
- ~use-package!~ for configuring packages
- ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
  you load packages with ~require~ or ~use-package~
- ~map!~ for binding new keys
*** Allow babel execution in CLI actions
In this config I sometimes generate code to include in my config.
This works nicely, but for it to work with =doom sync= et. al. I need to make sure
that Org doesn't try to confirm that I want to allow evaluation (I do!).

Thankfully Doom supports =$DOOMDIR/cli.el= file which is sourced every time a CLI
command is run, so we can just enable evaluation by setting
~org-confirm-babel-evaluate~ to ~nil~ there.
While we're at it, we should silence ~org-babel-execute-src-block~ to
avoid polluting the output.
#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src
*** Pop up
#+begin_src emacs-lisp
(setq display-buffer-base-action
      '(display-buffer-reuse-mode-window
        display-buffer-reuse-window
        display-buffer-same-window))
;; If a popup does happen, don't resize windows to be equal-sized
(setq even-window-sizes nil)
(set-popup-rules!
  '(("^\\*doom" :ignore t)
    ("^\\*doom:\\(?:v?term\\|e?shell\\)-popup" :ignore t)
    ("^\\*\\(?:Wo\\)?Man " :ignore t)
    ("^\\*\\([Hh]elp\\|Apropos\\)" :ignore t)
    ("^\\*info\\*$" :ignore t)
    ("^\\*Backtrace" :ignore t)
    ("^\\*Org Src" :ignore t)
    ("^\\*Capture\\*$\\|CAPTURE-.*$" :ignore t)
    ("^\\*lsp-documentation" :ignore t)
    ("^\\*vterm" :ignore t)))
#+end_src
** Other things
*** Editor interaction
**** Mouse buttons

#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src

*** Window title

I'd like to have just the buffer name, then if applicable the project folder
#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "â˜° "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " â—‰ %s" " â€†â—â€† %s") project-name))))))
#+end_src

For example when I open my config file it the window will be titled =config.org â—
doom= then as soon as I make a change it will become =config.org â—‰ doom=.

*** Splash screen

Emacs can render an image as the splash screen, and [[https://github.com/MarioRicalde][@MarioRicalde]] came up with a
cracker! He's also provided me with a nice Emacs-style /E/. I was using the
blackhole image, but as I've stripped down the splash screen I've switched to
just using the /E/.

#+attr_latex: :width 0.2\linewidth
#+attr_html: :style width:20% :alt Fancy Emacs "E"
[[file:misc/splash-images/emacs-e.svg]]

Now we just make it theme-appropriate, and resize with the frame.

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

Now the only thing missing is a an extra interesting line, whether that be some
corporate BS, an developer excuse, or a fun (useless) fact.

The following is rather long, but it essentially
+ fetches a phrase from an API
+ inserts it into the dashboard (asynchronously)
+ moves ~point~ to the phrase
+ re-uses the last phrase for requests within a few seconds of it being fetched

#+begin_src emacs-lisp
(defvar splash-phrase-source-folder
  (expand-file-name "misc/splash-phrases" doom-private-dir)
  "A folder of text files with a fun phrase on each line.")

(defvar splash-phrase-sources
  (let* ((files (directory-files splash-phrase-source-folder nil "\\.txt\\'"))
         (sets (delete-dups (mapcar
                             (lambda (file)
                               (replace-regexp-in-string "\\(?:-[0-9]+-\\w+\\)?\\.txt" "" file))
                             files))))
    (mapcar (lambda (sset)
              (cons sset
                    (delq nil (mapcar
                               (lambda (file)
                                 (when (string-match-p (regexp-quote sset) file)
                                   file))
                               files))))
            sets))
  "A list of cons giving the phrase set name, and a list of files which contain phrase components.")

(defvar splash-phrase-set
  (nth (random (length splash-phrase-sources)) (mapcar #'car splash-phrase-sources))
  "The default phrase set. See `splash-phrase-sources'.")

(defun splase-phrase-set-random-set ()
  "Set a new random splash phrase set."
  (interactive)
  (setq splash-phrase-set
        (nth (random (1- (length splash-phrase-sources)))
             (cl-set-difference (mapcar #'car splash-phrase-sources) (list splash-phrase-set))))
  (+doom-dashboard-reload t))

(defvar splase-phrase--cache nil)

(defun splash-phrase-get-from-file (file)
  "Fetch a random line from FILE."
  (let ((lines (or (cdr (assoc file splase-phrase--cache))
                   (cdar (push (cons file
                                     (with-temp-buffer
                                       (insert-file-contents (expand-file-name file splash-phrase-source-folder))
                                       (split-string (string-trim (buffer-string)) "\n")))
                               splase-phrase--cache)))))
    (nth (random (length lines)) lines)))

(defun splash-phrase (&optional set)
  "Construct a splash phrase from SET. See `splash-phrase-sources'."
  (mapconcat
   #'splash-phrase-get-from-file
   (cdr (assoc (or set splash-phrase-set) splash-phrase-sources))
   " "))

(defun doom-dashboard-phrase ()
  "Get a splash phrase, flow it over multiple lines as needed, and make fontify it."
  (mapconcat
   (lambda (line)
     (+doom-dashboard--center
      +doom-dashboard--width
      (with-temp-buffer
        (insert-text-button
         line
         'action
         (lambda (_) (+doom-dashboard-reload t))
         'face 'doom-dashboard-menu-title
         'mouse-face 'doom-dashboard-menu-title
         'help-echo "Random phrase"
         'follow-link t)
        (buffer-string))))
   (split-string
    (with-temp-buffer
      (insert (splash-phrase))
      (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
      (fill-region (point-min) (point-max))
      (buffer-string))
    "\n")
   "\n"))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

Lastly, the doom dashboard "useful commands" are no longer useful to me.
So, we'll disable them and then for a particularly /clean/ look disable
the modeline and ~hl-line-mode~, then also hide the cursor.

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

At the end, we have a minimal but rather nice splash screen.

#+attr_html: :class invertible :alt The splash screen, just loaded.
[[https://tecosaur.com/lfs/emacs-config/screenshots/splash-screen.png]]

I haven't forgotten about the ASCII banner though! Once again we're going for
something simple.

#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(",---.,-.-.,---.,---.,---."
            "|---'| | |,---||    `---."
            "`---'` ' '`---^`---'`---'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

*** Emacs client wrapper

I frequently want to make use of Emacs while in a terminal emulator. To make
this easier, I can construct a few handy aliases.

However, a little convenience script in =~/.local/bin= can have the same effect,
be available beyond the specific shell I plop the alias in, then also allow me
to add a few bells and whistles --- namely:
+ Accepting stdin by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behaviour (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =ksh= etc. should work too.

#+name: ee
#+begin_src shell :tangle ~/.local/bin/ee :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        ,*)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
        && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
fi
#+end_src

Now, to set an alias to use =e= with magit, and then for maximum laziness we can
set aliases for the terminal-forced variants.
#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src

*** Prompt to run setup script

At various points in this config, content is conditionally tangled to
=./setup.sh=. It's no good just putting content there if it isn't run though.
To help remind me to run it when needed, let's add a little prompt when there's
anything to be run.

#+name: run-setup
#+begin_src emacs-lisp :tangle no
(if (file-exists-p "setup.sh")
    (if (string-empty-p (string-trim (with-temp-buffer (insert-file-contents "setup.sh") (buffer-string)) "#!/usr/bin/env bash"))
        (message ";; Setup script is empty")
      (message ";; Detected content in the setup script")
      (pp-to-string
       `(unless noninteractive
          (defun +config-run-setup ()
            (when (yes-or-no-p (format "%s The setup script has content. Check and run the script?"
                                       (propertize "Warning!" 'face '(bold warning))))
              (find-file (expand-file-name "setup.sh" doom-private-dir))
              (when (yes-or-no-p "Would you like to run this script?")
                (async-shell-command "./setup.sh"))))
          (add-hook! 'doom-init-ui-hook
            (run-at-time nil nil #'+config-run-setup)))))
  (message ";; setup.sh did not exist during tangle. Tangle again.")
  (pp-to-string
   `(unless noninteractive
      (add-hook! 'doom-init-ui-hook #'+literate-tangle-async-h))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<run-setup()>>
#+end_src

* Keybinds
** Buffer
#+begin_src emacs-lisp :tangle no
(map! :leader :prefix ("b" . "buffer")
      :desc "List all buffer" "i" #'list-buffers)
#+end_src
** Dashboard quick actions
When using the dashboard, there are often a small number of actions I will take.
As the dashboard is it's own major mode, there is no need to suffer the tyranny
of unnecessary keystrokes --- we can simply bind common actions to a single key!

#+begin_src emacs-lisp
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ne "f" #'find-file
        :desc "Recent files" :ne "r" #'consult-recent-file
        :desc "Config dir" :ne "C" #'doom/open-private-config
        :desc "Open config.org" :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ne "." (cmd! (doom-project-find-file "~/.dotfiles/"))
        :desc "Scratch buffer" :ne "x" (cmd! (scratch-buffer))
        :desc "Notes (roam)" :ne "n" #'org-roam-node-find
        :desc "Switch buffer" :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer" :ne "i" #'ibuffer
        :desc "Previous buffer" :ne "p" #'previous-buffer
        :desc "Set theme" :ne "t" #'consult-theme
        :desc "Quit" :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ne "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

Unfortunately the show keybindings help doesn't currently work as intended, but
this is still quite nice overall.

Now that the dashboard is so convenient, I'll want to make it easier to get to.
#+begin_src emacs-lisp
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src

** Dired
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("e" . "dired")
       :desc "Open dired" "e" #'dired
       :desc "Dired jump to current" "j" #'dired-jump)
      (:after dired
       (:map dired-mode-map
        :desc "Peep-dired image previews" "e p" #'peep-dired
        :desc "Dired view file" "e v" #'dired-view-file)))

(evil-define-key 'normal dired-mode-map
  (kbd "M-RET") 'dired-display-file
  (kbd "h") 'dired-up-directory
  (kbd "l") 'dired-open-file ; use dired-find-file instead of dired-open.
  (kbd "s") 'dired-toggle-sudo
  (kbd "m") 'dired-mark
  (kbd "t") 'dired-toggle-marks
  (kbd "u") 'dired-unmark
  (kbd "C") 'dired-do-copy
  (kbd "D") 'dired-do-delete
  (kbd "J") 'dired-goto-file
  (kbd "M") 'dired-do-chmod
  (kbd "O") 'dired-do-chown
  (kbd "P") 'dired-do-print
  (kbd "R") 'dired-do-rename
  (kbd "T") 'dired-do-touch
  (kbd "Y") 'dired-copy-filenamecopy-filename-as-kill ; copies filename to kill ring.
  (kbd "+") 'dired-create-directory
  (kbd "-") 'dired-up-directory
  (kbd "% l") 'dired-downcase
  (kbd "% u") 'dired-upcase
  (kbd "; d") 'epa-dired-do-decrypt
  (kbd "; e") 'epa-dired-do-encrypt)
(evil-define-key 'normal peep-dired-mode-map
  (kbd "j") 'peep-dired-next-file
  (kbd "k") 'peep-dired-prev-file)
(add-hook 'peep-dired-hook 'evil-normalize-keymaps)
#+end_src
** Magit
#+begin_src emacs-lisp
(map! :leader
      :desc "magit-status-dotfiles" "g b"'me/magit-status-dotfiles
      :desc "magit-status-org" "g w"'me/magit-status-org
      :desc "magit-status" "g g"'me/magit-status)
#+end_src
** Window
Window rotation is nice, and can be found under =SPC w r= and =SPC w R=.
/Layout/ rotation is also nice though. Let's stash this under =SPC w SPC=, inspired
by Tmux's use of =C-b SPC= to rotate windows.

We could also do with adding the missing arrow-key variants of the window
navigation/swapping commands.
#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      ;; Navigation
      "<left>"     #'evil-window-left
      "<down>"     #'evil-window-down
      "<up>"       #'evil-window-up
      "<right>"    #'evil-window-right
      ;; Swapping windows
      "C-<left>"       #'+evil/window-move-left
      "C-<down>"       #'+evil/window-move-down
      "C-<up>"         #'+evil/window-move-up
      "C-<right>"      #'+evil/window-move-right)
#+end_src
** Mouse buttons
#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src
** Naming convention
#+begin_src emacs-lisp
(map! :leader :prefix ("c~" . "naming convention")
      :desc "cycle" "~" #'string-inflection-all-cycle
      :desc "toggle" "t" #'string-inflection-toggle
      :desc "CamelCase" "c" #'string-inflection-camelcase
      :desc "downCase" "d" #'string-inflection-lower-camelcase
      :desc "kebab-case" "k" #'string-inflection-kebab-case
      :desc "under_score" "_" #'string-inflection-underscore
      :desc "Upper_Score" "u" #'string-inflection-capital-underscore
      :desc "UP_CASE" "U" #'string-inflection-upcase)
#+end_src
